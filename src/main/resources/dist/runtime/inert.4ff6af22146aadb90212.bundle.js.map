{"version":3,"sources":["webpack://lib_alpha_prototype/inert.ts","webpack://lib_alpha_prototype/./node_modules/wicg-inert/dist/inert.js"],"names":["__webpack_require__","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","slice","Array","matches","Element","msMatchesSelector","_focusableElementsString","join","InertRoot","rootElement","inertManager","this","_inertManager","_rootElement","_managedNodes","Set","hasAttribute","_savedAriaHidden","getAttribute","setAttribute","_makeSubtreeUnfocusable","_observer","MutationObserver","_onMutation","bind","observe","attributes","childList","subtree","value","disconnect","removeAttribute","forEach","inertNode","_unmanageNode","node","startNode","_this2","composedTreeWalk","_visitNode","activeElement","document","body","contains","root","undefined","nodeType","Node","DOCUMENT_FRAGMENT_NODE","parentNode","blur","focus","ELEMENT_NODE","element","_adoptInertRoot","call","_manageNode","register","add","deregister","_this3","inertSubroot","getInertRoot","setInert","managedNodes","savedInertNode","records","self","record","type","addedNodes","removedNodes","_unmanageSubtree","attributeName","managedNode","get","set","ariaHidden","InertNode","inertRoot","_node","_overrodeFocusMethod","_inertRoots","_savedTabIndex","_destroyed","ensureUntabbable","_throwIfDestroyed","destroyed","Error","tabIndex","hasSavedTabIndex","size","destructor","callback","shadowRootAncestor","shadowRoot","localName","content","distributedNodes","getDistributedNodes","slot","_distributedNodes","assignedNodes","flatten","_i","child","firstChild","nextSibling","addInertStyle","querySelector","style","createElement","textContent","appendChild","InertManager","_document","Map","_watchForInert","head","documentElement","readyState","addEventListener","_onDocumentLoaded","inert","has","parent","_inertRoot","addInertRoot","removeInertRoot","inertElements","querySelectorAll","inertElement","_this","unshift","hasOwnProperty","factory"],"mappings":"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","file":"runtime/inert.4ff6af22146aadb90212.bundle.js","sourcesContent":["`!has('build-elide')`;\nrequire('wicg-inert/dist/inert');\n","(function (global, factory) {\r\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory() :\r\n  typeof define === 'function' && define.amd ? define('inert', factory) :\r\n  (factory());\r\n}(this, (function () { 'use strict';\r\n\r\n  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\r\n\r\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\n  /**\r\n   * This work is licensed under the W3C Software and Document License\r\n   * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).\r\n   */\r\n\r\n  // Convenience function for converting NodeLists.\r\n  /** @type {typeof Array.prototype.slice} */\r\n  var slice = Array.prototype.slice;\r\n\r\n  /**\r\n   * IE has a non-standard name for \"matches\".\r\n   * @type {typeof Element.prototype.matches}\r\n   */\r\n  var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;\r\n\r\n  /** @type {string} */\r\n  var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');\r\n\r\n  /**\r\n   * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`\r\n   * attribute.\r\n   *\r\n   * Its main functions are:\r\n   *\r\n   * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the\r\n   *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering\r\n   *   each focusable node in the subtree with the singleton `InertManager` which manages all known\r\n   *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`\r\n   *   instance exists for each focusable node which has at least one inert root as an ancestor.\r\n   *\r\n   * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`\r\n   *   attribute is removed from the root node). This is handled in the destructor, which calls the\r\n   *   `deregister` method on `InertManager` for each managed inert node.\r\n   */\r\n\r\n  var InertRoot = function () {\r\n    /**\r\n     * @param {!Element} rootElement The Element at the root of the inert subtree.\r\n     * @param {!InertManager} inertManager The global singleton InertManager object.\r\n     */\r\n    function InertRoot(rootElement, inertManager) {\r\n      _classCallCheck(this, InertRoot);\r\n\r\n      /** @type {!InertManager} */\r\n      this._inertManager = inertManager;\r\n\r\n      /** @type {!Element} */\r\n      this._rootElement = rootElement;\r\n\r\n      /**\r\n       * @type {!Set<!InertNode>}\r\n       * All managed focusable nodes in this InertRoot's subtree.\r\n       */\r\n      this._managedNodes = new Set();\r\n\r\n      // Make the subtree hidden from assistive technology\r\n      if (this._rootElement.hasAttribute('aria-hidden')) {\r\n        /** @type {?string} */\r\n        this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');\r\n      } else {\r\n        this._savedAriaHidden = null;\r\n      }\r\n      this._rootElement.setAttribute('aria-hidden', 'true');\r\n\r\n      // Make all focusable elements in the subtree unfocusable and add them to _managedNodes\r\n      this._makeSubtreeUnfocusable(this._rootElement);\r\n\r\n      // Watch for:\r\n      // - any additions in the subtree: make them unfocusable too\r\n      // - any removals from the subtree: remove them from this inert root's managed nodes\r\n      // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable\r\n      //   element, make that node a managed node.\r\n      this._observer = new MutationObserver(this._onMutation.bind(this));\r\n      this._observer.observe(this._rootElement, { attributes: true, childList: true, subtree: true });\r\n    }\r\n\r\n    /**\r\n     * Call this whenever this object is about to become obsolete.  This unwinds all of the state\r\n     * stored in this object and updates the state of all of the managed nodes.\r\n     */\r\n\r\n\r\n    _createClass(InertRoot, [{\r\n      key: 'destructor',\r\n      value: function destructor() {\r\n        this._observer.disconnect();\r\n\r\n        if (this._rootElement) {\r\n          if (this._savedAriaHidden !== null) {\r\n            this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);\r\n          } else {\r\n            this._rootElement.removeAttribute('aria-hidden');\r\n          }\r\n        }\r\n\r\n        this._managedNodes.forEach(function (inertNode) {\r\n          this._unmanageNode(inertNode.node);\r\n        }, this);\r\n\r\n        // Note we cast the nulls to the ANY type here because:\r\n        // 1) We want the class properties to be declared as non-null, or else we\r\n        //    need even more casts throughout this code. All bets are off if an\r\n        //    instance has been destroyed and a method is called.\r\n        // 2) We don't want to cast \"this\", because we want type-aware optimizations\r\n        //    to know which properties we're setting.\r\n        this._observer = /** @type {?} */null;\r\n        this._rootElement = /** @type {?} */null;\r\n        this._managedNodes = /** @type {?} */null;\r\n        this._inertManager = /** @type {?} */null;\r\n      }\r\n\r\n      /**\r\n       * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.\r\n       */\r\n\r\n    }, {\r\n      key: '_makeSubtreeUnfocusable',\r\n\r\n\r\n      /**\r\n       * @param {!Node} startNode\r\n       */\r\n      value: function _makeSubtreeUnfocusable(startNode) {\r\n        var _this2 = this;\r\n\r\n        composedTreeWalk(startNode, function (node) {\r\n          return _this2._visitNode(node);\r\n        });\r\n\r\n        var activeElement = document.activeElement;\r\n\r\n        if (!document.body.contains(startNode)) {\r\n          // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.\r\n          var node = startNode;\r\n          /** @type {!ShadowRoot|undefined} */\r\n          var root = undefined;\r\n          while (node) {\r\n            if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\r\n              root = /** @type {!ShadowRoot} */node;\r\n              break;\r\n            }\r\n            node = node.parentNode;\r\n          }\r\n          if (root) {\r\n            activeElement = root.activeElement;\r\n          }\r\n        }\r\n        if (startNode.contains(activeElement)) {\r\n          activeElement.blur();\r\n          // In IE11, if an element is already focused, and then set to tabindex=-1\r\n          // calling blur() will not actually move the focus.\r\n          // To work around this we call focus() on the body instead.\r\n          if (activeElement === document.activeElement) {\r\n            document.body.focus();\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * @param {!Node} node\r\n       */\r\n\r\n    }, {\r\n      key: '_visitNode',\r\n      value: function _visitNode(node) {\r\n        if (node.nodeType !== Node.ELEMENT_NODE) {\r\n          return;\r\n        }\r\n        var element = /** @type {!Element} */node;\r\n\r\n        // If a descendant inert root becomes un-inert, its descendants will still be inert because of\r\n        // this inert root, so all of its managed nodes need to be adopted by this InertRoot.\r\n        if (element !== this._rootElement && element.hasAttribute('inert')) {\r\n          this._adoptInertRoot(element);\r\n        }\r\n\r\n        if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {\r\n          this._manageNode(element);\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Register the given node with this InertRoot and with InertManager.\r\n       * @param {!Node} node\r\n       */\r\n\r\n    }, {\r\n      key: '_manageNode',\r\n      value: function _manageNode(node) {\r\n        var inertNode = this._inertManager.register(node, this);\r\n        this._managedNodes.add(inertNode);\r\n      }\r\n\r\n      /**\r\n       * Unregister the given node with this InertRoot and with InertManager.\r\n       * @param {!Node} node\r\n       */\r\n\r\n    }, {\r\n      key: '_unmanageNode',\r\n      value: function _unmanageNode(node) {\r\n        var inertNode = this._inertManager.deregister(node, this);\r\n        if (inertNode) {\r\n          this._managedNodes['delete'](inertNode);\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Unregister the entire subtree starting at `startNode`.\r\n       * @param {!Node} startNode\r\n       */\r\n\r\n    }, {\r\n      key: '_unmanageSubtree',\r\n      value: function _unmanageSubtree(startNode) {\r\n        var _this3 = this;\r\n\r\n        composedTreeWalk(startNode, function (node) {\r\n          return _this3._unmanageNode(node);\r\n        });\r\n      }\r\n\r\n      /**\r\n       * If a descendant node is found with an `inert` attribute, adopt its managed nodes.\r\n       * @param {!Element} node\r\n       */\r\n\r\n    }, {\r\n      key: '_adoptInertRoot',\r\n      value: function _adoptInertRoot(node) {\r\n        var inertSubroot = this._inertManager.getInertRoot(node);\r\n\r\n        // During initialisation this inert root may not have been registered yet,\r\n        // so register it now if need be.\r\n        if (!inertSubroot) {\r\n          this._inertManager.setInert(node, true);\r\n          inertSubroot = this._inertManager.getInertRoot(node);\r\n        }\r\n\r\n        inertSubroot.managedNodes.forEach(function (savedInertNode) {\r\n          this._manageNode(savedInertNode.node);\r\n        }, this);\r\n      }\r\n\r\n      /**\r\n       * Callback used when mutation observer detects subtree additions, removals, or attribute changes.\r\n       * @param {!Array<!MutationRecord>} records\r\n       * @param {!MutationObserver} self\r\n       */\r\n\r\n    }, {\r\n      key: '_onMutation',\r\n      value: function _onMutation(records, self) {\r\n        records.forEach(function (record) {\r\n          var target = /** @type {!Element} */record.target;\r\n          if (record.type === 'childList') {\r\n            // Manage added nodes\r\n            slice.call(record.addedNodes).forEach(function (node) {\r\n              this._makeSubtreeUnfocusable(node);\r\n            }, this);\r\n\r\n            // Un-manage removed nodes\r\n            slice.call(record.removedNodes).forEach(function (node) {\r\n              this._unmanageSubtree(node);\r\n            }, this);\r\n          } else if (record.type === 'attributes') {\r\n            if (record.attributeName === 'tabindex') {\r\n              // Re-initialise inert node if tabindex changes\r\n              this._manageNode(target);\r\n            } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {\r\n              // If a new inert root is added, adopt its managed nodes and make sure it knows about the\r\n              // already managed nodes from this inert subroot.\r\n              this._adoptInertRoot(target);\r\n              var inertSubroot = this._inertManager.getInertRoot(target);\r\n              this._managedNodes.forEach(function (managedNode) {\r\n                if (target.contains(managedNode.node)) {\r\n                  inertSubroot._manageNode(managedNode.node);\r\n                }\r\n              });\r\n            }\r\n          }\r\n        }, this);\r\n      }\r\n    }, {\r\n      key: 'managedNodes',\r\n      get: function get() {\r\n        return new Set(this._managedNodes);\r\n      }\r\n\r\n      /** @return {boolean} */\r\n\r\n    }, {\r\n      key: 'hasSavedAriaHidden',\r\n      get: function get() {\r\n        return this._savedAriaHidden !== null;\r\n      }\r\n\r\n      /** @param {?string} ariaHidden */\r\n\r\n    }, {\r\n      key: 'savedAriaHidden',\r\n      set: function set(ariaHidden) {\r\n        this._savedAriaHidden = ariaHidden;\r\n      }\r\n\r\n      /** @return {?string} */\r\n      ,\r\n      get: function get() {\r\n        return this._savedAriaHidden;\r\n      }\r\n    }]);\r\n\r\n    return InertRoot;\r\n  }();\r\n\r\n  /**\r\n   * `InertNode` initialises and manages a single inert node.\r\n   * A node is inert if it is a descendant of one or more inert root elements.\r\n   *\r\n   * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and\r\n   * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element\r\n   * is intrinsically focusable or not.\r\n   *\r\n   * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an\r\n   * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the\r\n   * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s\r\n   * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,\r\n   * or removes the `tabindex` attribute if the element is intrinsically focusable.\r\n   */\r\n\r\n\r\n  var InertNode = function () {\r\n    /**\r\n     * @param {!Node} node A focusable element to be made inert.\r\n     * @param {!InertRoot} inertRoot The inert root element associated with this inert node.\r\n     */\r\n    function InertNode(node, inertRoot) {\r\n      _classCallCheck(this, InertNode);\r\n\r\n      /** @type {!Node} */\r\n      this._node = node;\r\n\r\n      /** @type {boolean} */\r\n      this._overrodeFocusMethod = false;\r\n\r\n      /**\r\n       * @type {!Set<!InertRoot>} The set of descendant inert roots.\r\n       *    If and only if this set becomes empty, this node is no longer inert.\r\n       */\r\n      this._inertRoots = new Set([inertRoot]);\r\n\r\n      /** @type {?number} */\r\n      this._savedTabIndex = null;\r\n\r\n      /** @type {boolean} */\r\n      this._destroyed = false;\r\n\r\n      // Save any prior tabindex info and make this node untabbable\r\n      this.ensureUntabbable();\r\n    }\r\n\r\n    /**\r\n     * Call this whenever this object is about to become obsolete.\r\n     * This makes the managed node focusable again and deletes all of the previously stored state.\r\n     */\r\n\r\n\r\n    _createClass(InertNode, [{\r\n      key: 'destructor',\r\n      value: function destructor() {\r\n        this._throwIfDestroyed();\r\n\r\n        if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {\r\n          var element = /** @type {!Element} */this._node;\r\n          if (this._savedTabIndex !== null) {\r\n            element.setAttribute('tabindex', this._savedTabIndex);\r\n          } else {\r\n            element.removeAttribute('tabindex');\r\n          }\r\n\r\n          // Use `delete` to restore native focus method.\r\n          if (this._overrodeFocusMethod) {\r\n            delete element.focus;\r\n          }\r\n        }\r\n\r\n        // See note in InertRoot.destructor for why we cast these nulls to ANY.\r\n        this._node = /** @type {?} */null;\r\n        this._inertRoots = /** @type {?} */null;\r\n        this._destroyed = true;\r\n      }\r\n\r\n      /**\r\n       * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.\r\n       * If the object has been destroyed, any attempt to access it will cause an exception.\r\n       */\r\n\r\n    }, {\r\n      key: '_throwIfDestroyed',\r\n\r\n\r\n      /**\r\n       * Throw if user tries to access destroyed InertNode.\r\n       */\r\n      value: function _throwIfDestroyed() {\r\n        if (this.destroyed) {\r\n          throw new Error('Trying to access destroyed InertNode');\r\n        }\r\n      }\r\n\r\n      /** @return {boolean} */\r\n\r\n    }, {\r\n      key: 'ensureUntabbable',\r\n\r\n\r\n      /** Save the existing tabindex value and make the node untabbable and unfocusable */\r\n      value: function ensureUntabbable() {\r\n        if (this.node.nodeType !== Node.ELEMENT_NODE) {\r\n          return;\r\n        }\r\n        var element = /** @type {!Element} */this.node;\r\n        if (matches.call(element, _focusableElementsString)) {\r\n          if ( /** @type {!HTMLElement} */element.tabIndex === -1 && this.hasSavedTabIndex) {\r\n            return;\r\n          }\r\n\r\n          if (element.hasAttribute('tabindex')) {\r\n            this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;\r\n          }\r\n          element.setAttribute('tabindex', '-1');\r\n          if (element.nodeType === Node.ELEMENT_NODE) {\r\n            element.focus = function () {};\r\n            this._overrodeFocusMethod = true;\r\n          }\r\n        } else if (element.hasAttribute('tabindex')) {\r\n          this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;\r\n          element.removeAttribute('tabindex');\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Add another inert root to this inert node's set of managing inert roots.\r\n       * @param {!InertRoot} inertRoot\r\n       */\r\n\r\n    }, {\r\n      key: 'addInertRoot',\r\n      value: function addInertRoot(inertRoot) {\r\n        this._throwIfDestroyed();\r\n        this._inertRoots.add(inertRoot);\r\n      }\r\n\r\n      /**\r\n       * Remove the given inert root from this inert node's set of managing inert roots.\r\n       * If the set of managing inert roots becomes empty, this node is no longer inert,\r\n       * so the object should be destroyed.\r\n       * @param {!InertRoot} inertRoot\r\n       */\r\n\r\n    }, {\r\n      key: 'removeInertRoot',\r\n      value: function removeInertRoot(inertRoot) {\r\n        this._throwIfDestroyed();\r\n        this._inertRoots['delete'](inertRoot);\r\n        if (this._inertRoots.size === 0) {\r\n          this.destructor();\r\n        }\r\n      }\r\n    }, {\r\n      key: 'destroyed',\r\n      get: function get() {\r\n        return (/** @type {!InertNode} */this._destroyed\r\n        );\r\n      }\r\n    }, {\r\n      key: 'hasSavedTabIndex',\r\n      get: function get() {\r\n        return this._savedTabIndex !== null;\r\n      }\r\n\r\n      /** @return {!Node} */\r\n\r\n    }, {\r\n      key: 'node',\r\n      get: function get() {\r\n        this._throwIfDestroyed();\r\n        return this._node;\r\n      }\r\n\r\n      /** @param {?number} tabIndex */\r\n\r\n    }, {\r\n      key: 'savedTabIndex',\r\n      set: function set(tabIndex) {\r\n        this._throwIfDestroyed();\r\n        this._savedTabIndex = tabIndex;\r\n      }\r\n\r\n      /** @return {?number} */\r\n      ,\r\n      get: function get() {\r\n        this._throwIfDestroyed();\r\n        return this._savedTabIndex;\r\n      }\r\n    }]);\r\n\r\n    return InertNode;\r\n  }();\r\n\r\n  /**\r\n   * InertManager is a per-document singleton object which manages all inert roots and nodes.\r\n   *\r\n   * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`\r\n   * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.\r\n   * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant\r\n   * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance\r\n   * is created for each such node, via the `_managedNodes` map.\r\n   */\r\n\r\n\r\n  var InertManager = function () {\r\n    /**\r\n     * @param {!Document} document\r\n     */\r\n    function InertManager(document) {\r\n      _classCallCheck(this, InertManager);\r\n\r\n      if (!document) {\r\n        throw new Error('Missing required argument; InertManager needs to wrap a document.');\r\n      }\r\n\r\n      /** @type {!Document} */\r\n      this._document = document;\r\n\r\n      /**\r\n       * All managed nodes known to this InertManager. In a map to allow looking up by Node.\r\n       * @type {!Map<!Node, !InertNode>}\r\n       */\r\n      this._managedNodes = new Map();\r\n\r\n      /**\r\n       * All inert roots known to this InertManager. In a map to allow looking up by Node.\r\n       * @type {!Map<!Node, !InertRoot>}\r\n       */\r\n      this._inertRoots = new Map();\r\n\r\n      /**\r\n       * Observer for mutations on `document.body`.\r\n       * @type {!MutationObserver}\r\n       */\r\n      this._observer = new MutationObserver(this._watchForInert.bind(this));\r\n\r\n      // Add inert style.\r\n      addInertStyle(document.head || document.body || document.documentElement);\r\n\r\n      // Wait for document to be loaded.\r\n      if (document.readyState === 'loading') {\r\n        document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));\r\n      } else {\r\n        this._onDocumentLoaded();\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Set whether the given element should be an inert root or not.\r\n     * @param {!Element} root\r\n     * @param {boolean} inert\r\n     */\r\n\r\n\r\n    _createClass(InertManager, [{\r\n      key: 'setInert',\r\n      value: function setInert(root, inert) {\r\n        if (inert) {\r\n          if (this._inertRoots.has(root)) {\r\n            // element is already inert\r\n            return;\r\n          }\r\n\r\n          var inertRoot = new InertRoot(root, this);\r\n          root.setAttribute('inert', '');\r\n          this._inertRoots.set(root, inertRoot);\r\n          // If not contained in the document, it must be in a shadowRoot.\r\n          // Ensure inert styles are added there.\r\n          if (!this._document.body.contains(root)) {\r\n            var parent = root.parentNode;\r\n            while (parent) {\r\n              if (parent.nodeType === 11) {\r\n                addInertStyle(parent);\r\n              }\r\n              parent = parent.parentNode;\r\n            }\r\n          }\r\n        } else {\r\n          if (!this._inertRoots.has(root)) {\r\n            // element is already non-inert\r\n            return;\r\n          }\r\n\r\n          var _inertRoot = this._inertRoots.get(root);\r\n          _inertRoot.destructor();\r\n          this._inertRoots['delete'](root);\r\n          root.removeAttribute('inert');\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Get the InertRoot object corresponding to the given inert root element, if any.\r\n       * @param {!Node} element\r\n       * @return {!InertRoot|undefined}\r\n       */\r\n\r\n    }, {\r\n      key: 'getInertRoot',\r\n      value: function getInertRoot(element) {\r\n        return this._inertRoots.get(element);\r\n      }\r\n\r\n      /**\r\n       * Register the given InertRoot as managing the given node.\r\n       * In the case where the node has a previously existing inert root, this inert root will\r\n       * be added to its set of inert roots.\r\n       * @param {!Node} node\r\n       * @param {!InertRoot} inertRoot\r\n       * @return {!InertNode} inertNode\r\n       */\r\n\r\n    }, {\r\n      key: 'register',\r\n      value: function register(node, inertRoot) {\r\n        var inertNode = this._managedNodes.get(node);\r\n        if (inertNode !== undefined) {\r\n          // node was already in an inert subtree\r\n          inertNode.addInertRoot(inertRoot);\r\n        } else {\r\n          inertNode = new InertNode(node, inertRoot);\r\n        }\r\n\r\n        this._managedNodes.set(node, inertNode);\r\n\r\n        return inertNode;\r\n      }\r\n\r\n      /**\r\n       * De-register the given InertRoot as managing the given inert node.\r\n       * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert\r\n       * node from the InertManager's set of managed nodes if it is destroyed.\r\n       * If the node is not currently managed, this is essentially a no-op.\r\n       * @param {!Node} node\r\n       * @param {!InertRoot} inertRoot\r\n       * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.\r\n       */\r\n\r\n    }, {\r\n      key: 'deregister',\r\n      value: function deregister(node, inertRoot) {\r\n        var inertNode = this._managedNodes.get(node);\r\n        if (!inertNode) {\r\n          return null;\r\n        }\r\n\r\n        inertNode.removeInertRoot(inertRoot);\r\n        if (inertNode.destroyed) {\r\n          this._managedNodes['delete'](node);\r\n        }\r\n\r\n        return inertNode;\r\n      }\r\n\r\n      /**\r\n       * Callback used when document has finished loading.\r\n       */\r\n\r\n    }, {\r\n      key: '_onDocumentLoaded',\r\n      value: function _onDocumentLoaded() {\r\n        // Find all inert roots in document and make them actually inert.\r\n        var inertElements = slice.call(this._document.querySelectorAll('[inert]'));\r\n        inertElements.forEach(function (inertElement) {\r\n          this.setInert(inertElement, true);\r\n        }, this);\r\n\r\n        // Comment this out to use programmatic API only.\r\n        this._observer.observe(this._document.body, { attributes: true, subtree: true, childList: true });\r\n      }\r\n\r\n      /**\r\n       * Callback used when mutation observer detects attribute changes.\r\n       * @param {!Array<!MutationRecord>} records\r\n       * @param {!MutationObserver} self\r\n       */\r\n\r\n    }, {\r\n      key: '_watchForInert',\r\n      value: function _watchForInert(records, self) {\r\n        var _this = this;\r\n        records.forEach(function (record) {\r\n          switch (record.type) {\r\n            case 'childList':\r\n              slice.call(record.addedNodes).forEach(function (node) {\r\n                if (node.nodeType !== Node.ELEMENT_NODE) {\r\n                  return;\r\n                }\r\n                var inertElements = slice.call(node.querySelectorAll('[inert]'));\r\n                if (matches.call(node, '[inert]')) {\r\n                  inertElements.unshift(node);\r\n                }\r\n                inertElements.forEach(function (inertElement) {\r\n                  this.setInert(inertElement, true);\r\n                }, _this);\r\n              }, _this);\r\n              break;\r\n            case 'attributes':\r\n              if (record.attributeName !== 'inert') {\r\n                return;\r\n              }\r\n              var target = /** @type {!Element} */record.target;\r\n              var inert = target.hasAttribute('inert');\r\n              _this.setInert(target, inert);\r\n              break;\r\n          }\r\n        }, this);\r\n      }\r\n    }]);\r\n\r\n    return InertManager;\r\n  }();\r\n\r\n  /**\r\n   * Recursively walk the composed tree from |node|.\r\n   * @param {!Node} node\r\n   * @param {(function (!Element))=} callback Callback to be called for each element traversed,\r\n   *     before descending into child nodes.\r\n   * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.\r\n   */\r\n\r\n\r\n  function composedTreeWalk(node, callback, shadowRootAncestor) {\r\n    if (node.nodeType == Node.ELEMENT_NODE) {\r\n      var element = /** @type {!Element} */node;\r\n      if (callback) {\r\n        callback(element);\r\n      }\r\n\r\n      // Descend into node:\r\n      // If it has a ShadowRoot, ignore all child elements - these will be picked\r\n      // up by the <content> or <shadow> elements. Descend straight into the\r\n      // ShadowRoot.\r\n      var shadowRoot = /** @type {!HTMLElement} */element.shadowRoot;\r\n      if (shadowRoot) {\r\n        composedTreeWalk(shadowRoot, callback, shadowRoot);\r\n        return;\r\n      }\r\n\r\n      // If it is a <content> element, descend into distributed elements - these\r\n      // are elements from outside the shadow root which are rendered inside the\r\n      // shadow DOM.\r\n      if (element.localName == 'content') {\r\n        var content = /** @type {!HTMLContentElement} */element;\r\n        // Verifies if ShadowDom v0 is supported.\r\n        var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];\r\n        for (var i = 0; i < distributedNodes.length; i++) {\r\n          composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\r\n        }\r\n        return;\r\n      }\r\n\r\n      // If it is a <slot> element, descend into assigned nodes - these\r\n      // are elements from outside the shadow root which are rendered inside the\r\n      // shadow DOM.\r\n      if (element.localName == 'slot') {\r\n        var slot = /** @type {!HTMLSlotElement} */element;\r\n        // Verify if ShadowDom v1 is supported.\r\n        var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({ flatten: true }) : [];\r\n        for (var _i = 0; _i < _distributedNodes.length; _i++) {\r\n          composedTreeWalk(_distributedNodes[_i], callback, shadowRootAncestor);\r\n        }\r\n        return;\r\n      }\r\n    }\r\n\r\n    // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>\r\n    // element, nor a <shadow> element recurse normally.\r\n    var child = node.firstChild;\r\n    while (child != null) {\r\n      composedTreeWalk(child, callback, shadowRootAncestor);\r\n      child = child.nextSibling;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds a style element to the node containing the inert specific styles\r\n   * @param {!Node} node\r\n   */\r\n  function addInertStyle(node) {\r\n    if (node.querySelector('style#inert-style')) {\r\n      return;\r\n    }\r\n    var style = document.createElement('style');\r\n    style.setAttribute('id', 'inert-style');\r\n    style.textContent = '\\n' + '[inert] {\\n' + '  pointer-events: none;\\n' + '  cursor: default;\\n' + '}\\n' + '\\n' + '[inert], [inert] * {\\n' + '  user-select: none;\\n' + '  -webkit-user-select: none;\\n' + '  -moz-user-select: none;\\n' + '  -ms-user-select: none;\\n' + '}\\n';\r\n    node.appendChild(style);\r\n  }\r\n\r\n  /** @type {!InertManager} */\r\n  var inertManager = new InertManager(document);\r\n\r\n  if (!Element.prototype.hasOwnProperty('inert')) {\r\n    Object.defineProperty(Element.prototype, 'inert', {\r\n      enumerable: true,\r\n      /** @this {!Element} */\r\n      get: function get() {\r\n        return this.hasAttribute('inert');\r\n      },\r\n      /** @this {!Element} */\r\n      set: function set(inert) {\r\n        inertManager.setInert(this, inert);\r\n      }\r\n    });\r\n  }\r\n\r\n})));\r\n"],"sourceRoot":""}